# -*- coding: utf-8 -*-

from behave import given, when, then
from hamcrest import (
    assert_that, contains_string, equal_to, has_length, has_item, not_,
)

from isotopic_logging import (
    direct_injector, static_injector, auto_injector, hybrid_injector,
)
from isotopic_logging.defaults import DELIMITER, OID_LENGTH


@given("I have a direct {prefix}")
def step_given_direct_prefix(context, prefix):
    context.prefix = prefix


@given("I have an injector of direct prefix")
def step_given_injector_of_direct_prefix(context):
    context.injector = direct_injector(prefix=context.prefix)


@when("I inject prefix into a {string}")
def step_when_mark_string_via_injector(context, string):
    context.string = string

    with context.injector as inj:
        context.result = inj.mark(string)


@then("resulting string must be equal to {expected_string}")
def step_resulting_string_must_be_equal_to_expected(context, expected_string):
    assert_that(context.result, equal_to(expected_string))


@then("resulting string must contain delimited prefix")
def step_resulting_string_must_contain_delimited_prefix(context):
    assert_that(context.result, contains_string(context.delimiter))

    chunks = context.result.split(context.delimiter, 1)
    assert_that(chunks, equal_to([context.prefix, context.string]))


@given("I have a static {prefix} and \"{delimiter}\" as a delimiter")
def step_given_static_prefix(context, prefix, delimiter):
    context.prefix = prefix
    context.delimiter = delimiter


@given("I have an injector of static prefix")
def step_given_injector_of_static_prefix(context):
    context.injector = static_injector(prefix=context.prefix,
                                       delimiter=context.delimiter)


@given("I don't care about prefix and delimeter")
def step_given_no_prefix_nor_delimeter(context):
    context.prefix = None
    context.delimiter = None


@given("I have an injector of autogenerated prefix")
def step_given_injector_of_autogenerated_prefix(context):
    context.injector = auto_injector()


@then("resulting string must be prefixed with autogenerated operation ID")
def step_then_string_must_be_prefixed_with_autogenerated_oid(context):
    assert_that(context.result, contains_string(DELIMITER))
    oid, string = context.result.split(DELIMITER, 1)

    assert_that(oid, has_length(OID_LENGTH))
    assert_that(string, equal_to(context.string))


@given("I have an injector of hybrid prefix")
def step_given_injector_of_hybrid_prefix(context):
    context.injector = hybrid_injector(prefix=context.prefix,
                                       delimiter=context.delimiter)


@then("resulting string must start with autogenerated prefix and static one")
def step_then_string_starts_with_autogenerated_prefix_and_static_one(context):
    assert_that(context.result, contains_string(context.delimiter))
    oid, prefix, string = context.result.split(context.delimiter, 2)

    assert_that(oid, has_length(OID_LENGTH))
    assert_that(prefix, equal_to(context.prefix))
    assert_that(string, equal_to(context.string))


@given("functions which call each other and produce different prefixes")
def step_given_functions(context):

    def foo():
        with static_injector("foo") as inj:
            return [inj.mark("foo string"), ]

    def bar():
        with static_injector("bar") as inj:
            result = [inj.mark("bar string"), ]
            result.extend(foo())
            return result

    def baz():
        with static_injector("baz") as inj:
            result = [inj.mark("baz string"), ]
            result.extend(foo())
            return result

    def qux():
        with static_injector("qux") as inj:
            result = [inj.mark("qux string"), ]
            result.extend(bar())
            result.extend(baz())
            return result

    context.functions = [foo, bar, baz, qux, ]


@when("I call a function")
def step_when_call_a_function(context):
    context.results = [function() for function in context.functions]


@then("prefix produced within it must be reused inside nested functions")
def step_then_reuse_prefix_inside_nested_functions(context):
    used_prefixes = []

    for results in context.results:
        unique_prefixes = list(set(
            result.split(DELIMITER, 1)[0]
            for result in results
        ))
        assert_that(unique_prefixes, has_length(1))

        prefix = unique_prefixes[0]
        assert_that(used_prefixes, not_(has_item(prefix)))

        used_prefixes.append(prefix)
